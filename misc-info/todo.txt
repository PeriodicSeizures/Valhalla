todo:
    - stop using std::optional for optional types
        use tinyoptional library instead

    - VH_PREFAB_INFO and VH_PORTABLE_ZDOS badly collide in implementation
        VH_PORTABLE_ZDOS refers to extra data present in a zdo to support modded zdos
            if this is solely for modded zdos, then consider 
            VH_PORTABLE_ZDOS or VH_MODDED_ZDOS
        
        VH_PREFAB_INFO refers to having the file-loaded prefabs with flag data
            required for world regeneration
            
    - restoring 'corrupt' worlds (assuming dungeon kind)
        if continuing types read is a possible vector matching:
            x y z {abs(x)<=10000 y>=5000 abs(z)<=10000}
        
        wait i might be fucking stupid
        
        the 8-bit count that is written to the world file is derived from 
        the actual int count
        
        we can use shifts to approximate the number of members 
        from a given count

    - add datareader peek function that samples at:
        - specified location
        - current location
        - offset relative to current location

    - todo create world backups prior to overwriting the source file
        or do writing to memory first, then write to file

    - fix the zdo-owner zdoid-userID overlap issue
        must handle gc and expedient creation
        
        either isolate zdo-owner and zdoid-userID pool contingencies or 
        use wider index types
        
        zdoid gets huge (dependent on all prior players) 
        but zdo-owner does not (dependent on current players)

    - either empty password or changing password during 
        runtime doesnt change is or something is broken

    - zdo owner vs zdoid userid
        both using the same id pool
        zdo owner is directly sourced from user server joins
        having this number tied in with userid interferes with the maximum expected capacity
        drasstically increasing it over the normal expected change over time
        this is only a real issue with large amounts of joins
        worst case rate:
            2 joins per hour per player
            10 players 
            2*24*10 = 480 players
            next acceptable power of 2 is 512 (9 bits) as a small server
            a large server would require a much larger number 
            
            or just throwaway this array entirely

    - use std::hardware_constructive_interference_size
        = seems 64-bytes
        
        remove zdo unique_ptr from zdomanager zdomap (will save 4-8 bytes depending on platform ptr size)

    - create runtime fallback prefab system to dynamically accept any kind of prefab
        this will basically create new prefabs on the fly for prefabs that dont exist while zdos are being loaded
        
        for a prefab binary tree, this complicates things, where any newly added prefab will shift all the other prefabs (once resorted to conform to binary tree spec)
        
        new consideration:
            load all zdos beforehand, querying all missing-prefabs
            then create all the missing prefabs
            sort the prefab tree
            reload the zdos (all prefabs should work now)
            
            RESOLVE_PREFABS_RUNTIME            
            DYNAMIC_PREFAB_RESOLUTION
            INITIAL_DYNAMIC_PREFABS (loads missing prefabs during world load)
            RUNTIME_DYNAMIC_PREFABS (loads missing prefabs at any time of the game world/network), not recommended for performant scenarios
            STORE_ZDO_PREFABS (will store the exact prefab hash within the ZDO as an additional member)
                if disabled, prefab indices will be stored instead of hashes
                enabling will increase memory consumption per ZDO
                
            experimental?:
                STORE_ZDO_FLAGS (will store the exact zdo sent flags within the zdo as an additional member)
                    if disabled, prefab flags will be stored instead of using zdo prefabs
                    enabling will increase memory consumption per ZDO
        
            REDUNDANT_ZDOS
                will store exact prefab hash, flags, ...
        
        perhaps the system used should 

    - consider a deduced system, and how much deducing is acceptable at the cost of memory/perf...
    
        have a system of maintaining the zdo's initial data (perhaps in heavily modded games?). In most cases this is extreme and can probably be ignored. 
        
        storing 'minimally required' data:
            persistent/distant/type are required and unable to be assumed based off zdo members
            
            terrain/portal... can be deduced based off zdo members (and prefab hash) as there is only a few of these types.
            
        the reason for all this is because im still disatisfied with the current pack system. its fine and all, but still seems too manual and tacky.
        
        consider grouping as such:
            - user/flags/prefab
            
                type is part of flags
                
        the least possible amount of bits is 16:
            - ~6: user bits (64 unique owners)
            - ~prefab: 12

	- rotations are screwed up
		not sure whether this is vegetation-spawning only, must test
		test with other players and placed items

    - implement RandomSpawn:
        - ZoneSystem Locations
        - DungeonGenerator Prefab Generation with rooms
        
        RandomSpawns use UnityEngine.Random to determine whether they will spawn
        
        The state for InitState is a seed
            - For ZoneSystem, it is the seed generated by the server or the seed retrieved from the ZDO (which is set by the server). So seed-synchronizaiton is really simple.
            Unity Random has already been properly implemented and is stable across platforms in Valhalla c++.
        
        RandomSpawns are a client side object that can show or hide a presentation object, an optional ZNetView object, and an 'off' object

        Data must be ripped from RandomSpawn in ValhallaDumper:
            - m_chanceToSpawn
            - m_dungeonRequireTheme
            - m_childNetViews
            - 

    - consider removing denotions and all hints until stable
        member hints are not stable (easy to forget to remove or add) 
        
        markers could be isolate numerical (separate pack indices instead of entire localdenotions)...

    - reset member flag(s) when member extracted from ZDO
        also reset connectors
        
    - might be able to shrink zdo connector value_type pair    
        type is a few bits (2 values are significant), 
        prefab target can be an index instead of 32-bit

    - server-side player inventories and metering
        player defaultingly spawns in with nothing (except for rag cloth)
        
        if player is new, treat inventory as empty
        
        only definite way to add/remove items from inventory:
            - ItemDrop::Pickup (causes zdo erase)
            - ItemDrop::Drop (causes zdo instantiate)
            - Inventory::MoveItemToThisContainer -> Container::OnContainerChanged triggers a ZDO save
            - Crafting (a bit is unknown about this on client side, no way to validate?)

    - leviathans sinking when leaving area
        probably something to do with server needing to do something with them
        
        possible ideas:
            if leviathan not at y=0 prior to peer leaving, consider setting height to 40 or something to prevent peer from fucking up everything
            
            hopefully this causes peer to only lower the leviathan down towards the surface instead of down to bedrock

    - fix dungeon netview orientations
        some netviews in DG_Cave (crystal in this small corrider) and the roots when entering crypt are either floating or in the way. 
        
        seemingly another root in a different crypt is fine... (i think it has to do with not applying correct rotations) I bet this is the issue because crypt mud piles are misaligned in a room (too much to the side in start room)
        
    - legal zdo spawning / tracking (illegal item / object spawning mitigation)
        basically prevent players from spawning the un-grabbable draugr axe etc...
        these weird items exist so that npc / characters are able to display them and use stats due to the way the game was made. The player however is not allowed to use them for obvious reasons. Will gid deeper to find what makes the player able to pick up or unable to pickup certain items, and will use that to base the legal item filter against
        
        can easily implement zdo searcher to see who spawns in certain zdos, who modified which zdos at whichever time, maybe even a replay tool? would be interesting, kinda reminds me of using wireshark to log packets. Basically replay the client conversation to the server visa-versa.      

    - boat-lagg fix (important or not?)
        when a player (owner) temporarily stops sending packets, the boat will be much ahead, causing other players to be in the previous position.
        a possible idea would be to identify any instantaneous change in position, not impulse or integral velocity (since position in this sense is a simple sudden change due to lagg spike)
        
        could try resetting player-owner, setting position, then setting owner back (hmm, must experiment because this abuses the particular code of ZSyncTransform--- I am not sure how the client might respond to this). This must be carried out over several frames, not all at once...
        
        Player.Teleport does work, but it is a whole slow sequence. It does not actually teleport the player instantaneously because it is meant for slow loading areas from long distance portal travels. The above ZSyncTransform idea is the best bet at something to tp the player instantaneousy, but possibly finicky and buggy. must test...

    - fix server shutdown routines
        - has hardly been worked on in months, very outdated and maybe unsafe or unimplemented, ie. 
            - save world, 
            - proper cleanup / disposal of managers
   
    - the below priority will require NetView method capture, abstraction and high performance code will be c++, with the extensions and behaviour in lua.
    
    - ZDO restore / reconciliation to prevent illegal modification by malicious clients
        
    - ZDO based item assign 
        Container::RPC_TakeAllRespons
            appears to insert all items in inventory to local player
        - Player death causes entire inventory to be moved to tombstone
            this is clientside, as usual
        - detect events via incoming updated zdos
    
    - fix mistlands mist distribution
        literally a blanket
        possibly vegetation mask broken?
        is vegetation being correctly skipped or placed as needed?

    - cleanup used heightmaps after time
        or could generate everything
          
    - calc server memory consumption
        zdos primarily...
        estimated based on sizeof(ZDO) and number of zdos
            not entirely accurate because zdos themselves allocate memory,
       
    - vegetation pkg values might need tweaking
        swamp trees are kinda not distributed?
        
    - block WNT packets?
        cause particles to spawn on screen likely causing lagg if many 
    
    - send zdos more/less often/more depending on network load and per-client latency
    
    - use bitshift for Biome type (instead of mask)

    - modify RouteManager to not have so much peer indirection
        (stop with ints...)
    
    - option for setting zone area distance in config
        
    - optimize zdo padding more?
        experiment with member offsets...
        masks for bool types
        
    - idea for unloading/destroying/reconciliating inactive zdos in world:
        - if zdo is a once-visited type (rock, trees, basically exploratory), and hardly ever visited, could unload to disk if necessary for memory...
        
finished:
    - owners not being assigned or sent correctly
        was occuring due to in-zdo persistent flags never being assigned for instantiations during zone generation (sonsequently was only occur during this case)

    - GoblinCamp2 - very crammed
        fixed

    - fix dungeon generation
        either go back to using mild accuracy rotated rect detection
        OR
        use normalized grid room overlap detection, where each room takes up nodes,
        and has max size:
            since im assuming each room has a normalized/unit size, find this out, then create a grid of nodes equal to 64/UNIT (where unit is the smallest square room). Collision detection will just be detecting whether a grid is occupied
            
            what about end caps? they might be emall and weirdly sized, so im not sure about this method
            
            another method could be to just stop using complex rotated rectangle collision, since im having insane troubles with that. INSTEAD, use regular rectangle collision with a normalized rotation grid, then apply all rotation to rooms after its done.
            
            Either way, I cant continue making so many features that already exist in unity. I thought this would be simple, but the method the devs use is not so simple. I will find a way around this.

    - change room netviews instantiate transforms to correctly reflect new pkg transform write (most local)
    
        also observe any usages of templated room.position (not instanced) or localPos or rotation for significance in keeping?
        
    - dungeons currently being worked on

    - fix general-Valheim latency issues (regarding client-side processing)
        theres no real good fix to this without changing the core networking and mechanics of the game
        
        Possible solutions:
            - reassign zdos to the nearest player 
            - reassign zdos radially to players, except in overlaps
            
        Biggest caveats/important aspects/most frequent annoyances:
            - COMBAT (Parrying especially) / Pickable/PickableItem under another zone-client is annoying, and most always laggy,
                so, likely reassign owners during these situations:
                    combat might be partially fixed by reassigning to the nearest player, only when players are fa apart from each other, and depends on distance of zdo-enemy in question

    - trying to get a way to represent zdo-components (members) without convoluting everything
        - each gameobject has only 1 zdo, therefore each zdo can refer to 1 gameobject, along with its properties (or more statically, its prefab capabilities):
        - whether the object is a:
            - Piece (Buildable/Placeable by player)
            - ItemDrop (Dropped Ground Item)
            - CraftingStation
            - WearNTear (Structural support / durability)
            - Pickable (Seasoning vegetation / goblin totem poles / Respawnable stuff)
            - DropOnDestroyed (destroyed objects drop)
            - CharacterDrop (killed entities drop)
            - Humanoid
            - MonsterAI

    - Use 64bit hash for ZDO map (mutated-only) so that collisions become nearly impossible

    - Container::inUse wrongly named zdo hash
        typo

    - fix zdos on save:
        chests Resetting
        Terrain Resetting
        Rocks Resetting
        Wards disabling
        Signs Resetting
        Fermenter Resetting
        Beds Resetting
        
        - ZDO save -> write issue fixed

    - consolidate all player notification messages into one method
        single useful Message(msg, type)

    - mod event error handler
        mod callback disabled if any error

    - fix log file backups
        compressed to /logs

    - test whether players work right near edge of world, or zdos...
        vegetation is not placed near edge of world, this might be why
        
        instead of square zone checks, check radially (within bounds of circular world)
        
    - test reducing world size to 313
        also add constraints when near edge of world
        so index bounds issues wont happen

    - implement quaternion euler fully
    
    - implement quaternion lookdirection fully
        so that prefabs are rotated correctly on worldgen
        broken in cases where an axis is zero or near zero

    - implement portals
        portals now link together with the help of a lua mod 
        
    - mods?
        comfy compress mod implemented

    - have method to get normal vector of heightmap at position
        consider using 4-pt normal for more acc normals if simple and fast enough
        
        but simple 2-pt normals work fine

    - world saving apparently broken (loading however is fully supported)
        was skipping utf-8 that had 3 total encoded byte sizes instead of the expected 2 -> 3 bytes

    - high priority: add full utf-8 char encoding and decoding for full Valheim c# compat
        current asystem is lazy and will only work with single bytes up to count 127, beyond that is special encoding...

    - restructure netpackage 
        - rename + make underlying stream use a ptr vec...
        - stream in many cases should be read only, like reading data incrementally, without copying when sub packages need making

    - prevent players spaces or non-ascii from joining
        or just invalid names
        or normalize the name (condense code points, dont just remove)

    - tweak vegetation rocks overlap radius
        perhaps too large, because black forest looks somewhat sparse compared to normal
    
    - work on vegetation overlap prevention

    - add option to immediately allow once-passworded users whove joined before
    - print a message to player on login whether auto logged in
        yes
    
    - locations appear to be offset by 1/2 of their width (along 1 axis), probably due to the way unity derives the final object position from instantiations in accordance with scale
    
    - check if ban command sends spaces
        it only sends the first split text...
        
    - try using Heightmap:: Biome and BiomeArea methods again, instead of geo (might be causing post-smoothing biome problems)
        it seems to have worked!